%{
#include "parser.tab.hpp" // Header generated by Bison
#include <string>

// This tells Flex to read from the file provided by the main function
extern FILE* yyin;

// Declare yylval with proper type
SK::Parser::value_type yylval;

// Declare the lexer function to match parser expectations
int yylex(void* yylval_ptr);

%}

%option noyywrap

%%

"~".* { /* Ignore comments */ }
[ \t\n\r\f\v]+        { /* Ignore all standard whitespace */ }           { /* Ignore whitespace */ }

"make"                { return SK::Parser::token::MAKE; }
"num"                 { yylval.str_val = new std::string(yytext); return SK::Parser::token::TYPE; }
"text"                { yylval.str_val = new std::string(yytext); return SK::Parser::token::TYPE; }
"show"                { return SK::Parser::token::SHOW; }
"check"               { return SK::Parser::token::CHECK; }
"otherwise"           { return SK::Parser::token::OTHERWISE; }
"during"              { return SK::Parser::token::DURING; }
"do"                  { return SK::Parser::token::DO; }
"ask"                 { return SK::Parser::token::ASK; }
\"[^"]*\"             { yylval.str_val = new std::string(yytext + 1, strlen(yytext) - 2); return SK::Parser::token::STRING; }

[a-zA-Z_][a-zA-Z0-9_]* { yylval.str_val = new std::string(yytext); return SK::Parser::token::ID; }
[0-9]+                { yylval.int_val = std::stoi(yytext); return SK::Parser::token::NUMBER; }

";"                   { return SK::Parser::token::SEMI; }
"="                   { return SK::Parser::token::ASSIGN; }
"("                   { return SK::Parser::token::LPAREN; }
")"                   { return SK::Parser::token::RPAREN; }
"{"                   { return SK::Parser::token::LBRACE; }
"}"                   { return SK::Parser::token::RBRACE; }
","                   { return SK::Parser::token::COMMA; }
"+"                   { return SK::Parser::token::PLUS; }
"-"                   { return SK::Parser::token::MINUS; }
"*"                   { return SK::Parser::token::MUL; }
"/"                   { return SK::Parser::token::DIV; }
"=="                  { return SK::Parser::token::EQ; }
"!="                  { return SK::Parser::token::NE; }
">"                   { return SK::Parser::token::GT; }
"<"                   { return SK::Parser::token::LT; }
">="                  { return SK::Parser::token::GE; }
"<="                  { return SK::Parser::token::LE; }

.                     { std::cerr << "Lexical Error: Unexpected character '" << yytext << "'\n"; exit(1); }

%%
// Custom yylex implementation to bridge between parser expectations and flex default behavior
int yylex(void* yylval_ptr) {
    SK::Parser::value_type* val = static_cast<SK::Parser::value_type*>(yylval_ptr);
    
    int token = yylex(); // Call the default flex-generated yylex
    
    if (token != 0) { // If not EOF
        *val = yylval; // Copy the global yylval to the passed pointer
    }
    
    return token;
}
