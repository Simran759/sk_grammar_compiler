%skeleton "lalr1.cc"
%require "3.2"
%defines
%define api.namespace {SK}
%define api.parser.class {Parser}

%code requires {
    #include "ast.hpp"
    #include <string>
    #include <memory>
    extern int yylex(void* yylval);
}

%parse-param { SK::ProgramNode* &ast_root }

%union {
    int int_val;
    std::string* str_val;
    SK::ExprNode* expr_node;
    SK::StmtNode* stmt_node;
    SK::ConditionNode* condition_node;
    SK::StmtList* stmt_list;
    std::vector<std::unique_ptr<SK::ExprNode>>* expr_list_vec;
}

%token <int_val> NUMBER
%token <str_val> ID TYPE STRING
%token MAKE SHOW CHECK OTHERWISE DURING DO ASK
%token LPAREN RPAREN LBRACE RBRACE SEMI COMMA ASSIGN
%token PLUS MINUS MUL DIV
%token EQ NE GT LT GE LE

%type <stmt_list> stmt_list
%type <stmt_node> stmt decl_stmt assign_stmt output_stmt if_stmt while_stmt
%type <expr_node> expr term
%type <expr_list_vec> expr_list
%type <condition_node> condition


%destructor { delete $$; } <str_val>

%left PLUS MINUS
%left MUL DIV

%%

program:
    stmt_list {
        ast_root = new SK::ProgramNode();
        ast_root->statements = std::move(*$1);
        delete $1;
    }
;

stmt_list:
    %empty { $$ = new SK::StmtList(); }
    | stmt_list stmt {
        $1->push_back(std::unique_ptr<SK::StmtNode>($2));
        $$ = $1;
    }
;


stmt:
    decl_stmt
    | assign_stmt
    | output_stmt
    | if_stmt
    | while_stmt
;

decl_stmt:
    MAKE TYPE ID SEMI { $$ = new SK::DeclStmtNode(*$2, *$3, nullptr); delete $2; delete $3; }
    | MAKE TYPE ID ASSIGN expr SEMI { $$ = new SK::DeclStmtNode(*$2, *$3, std::unique_ptr<SK::ExprNode>($5)); delete $2; delete $3; }
;

assign_stmt:
    ID ASSIGN expr SEMI { $$ = new SK::AssignStmtNode(*$1, std::unique_ptr<SK::ExprNode>($3)); delete $1; }
;

output_stmt:
    SHOW LPAREN expr_list RPAREN SEMI {
        $$ = new SK::OutputStmtNode(std::move(*$3)); delete $3;
    }
;

expr_list:
    expr { $$ = new std::vector<std::unique_ptr<SK::ExprNode>>(); $$->push_back(std::unique_ptr<SK::ExprNode>($1)); }
    | expr_list COMMA expr { $1->push_back(std::unique_ptr<SK::ExprNode>($3)); $$ = $1; }
;

if_stmt:
    CHECK LPAREN condition RPAREN LBRACE stmt_list RBRACE { $$ = new SK::IfStmtNode(std::unique_ptr<SK::ConditionNode>($3), std::move(*$6), SK::StmtList()); delete $6; }
    | CHECK LPAREN condition RPAREN LBRACE stmt_list RBRACE OTHERWISE LBRACE stmt_list RBRACE { $$ = new SK::IfStmtNode(std::unique_ptr<SK::ConditionNode>($3), std::move(*$6), std::move(*$10)); delete $6; delete $10; }
;

while_stmt:
    DURING LPAREN condition RPAREN LBRACE DO stmt_list RBRACE { $$ = new SK::WhileStmtNode(std::unique_ptr<SK::ConditionNode>($3), std::move(*$7)); delete $7; }
;

condition:
      expr GT expr  { $$ = new SK::ConditionNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::GT, std::unique_ptr<SK::ExprNode>($3)); }
    | expr LT expr  { $$ = new SK::ConditionNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::LT, std::unique_ptr<SK::ExprNode>($3)); }
    | expr EQ expr  { $$ = new SK::ConditionNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::EQ, std::unique_ptr<SK::ExprNode>($3)); }
    | expr NE expr  { $$ = new SK::ConditionNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::NE, std::unique_ptr<SK::ExprNode>($3)); }
    | expr GE expr  { $$ = new SK::ConditionNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::GE, std::unique_ptr<SK::ExprNode>($3)); }
    | expr LE expr  { $$ = new SK::ConditionNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::LE, std::unique_ptr<SK::ExprNode>($3)); }
;

expr:
    term { $$ = $1; }
    | expr PLUS term  { $$ = new SK::BinOpNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::PLUS, std::unique_ptr<SK::ExprNode>($3)); }
    | expr MINUS term { $$ = new SK::BinOpNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::MINUS, std::unique_ptr<SK::ExprNode>($3)); }
    | expr MUL term   { $$ = new SK::BinOpNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::MUL, std::unique_ptr<SK::ExprNode>($3)); }
    | expr DIV term   { $$ = new SK::BinOpNode(std::unique_ptr<SK::ExprNode>($1), SK::Parser::token::DIV, std::unique_ptr<SK::ExprNode>($3)); }
;

term:
    NUMBER { $$ = new SK::NumberNode($1); }
    | STRING { $$ = new SK::StringNode(*$1); delete $1; }
    | ID { $$ = new SK::IdNode(*$1); delete $1; }
    | LPAREN expr RPAREN { $$ = $2; }
;

%%


void SK::Parser::error(const std::string& msg) {
    std::cerr << "Parse Error: " << msg << std::endl;
}
